#!/bin/bash
# claude-watch - instructions.mdの変更を監視し、Claude Codeで自動実行するシステム
#
# 目的: 人間が「読んで実行して」とコピペする手間を排除する
# instructions.mdに書くだけでClaude Codeが自動的に読み取り実行する
#
# 方式: ポーリング（5秒間隔でタイムスタンプチェック）
# WSL2でWindows側からの書き込みがinotifyで検知できないため
# 外部依存なし
#
# Usage:
#   claude-watch                    # ~/instructions.md を監視（デフォルト）
#   claude-watch /path/to/file.md   # 指定ファイルを監視
#   claude-watch --status           # 状態確認
#   claude-watch --stop             # 停止
#   claude-watch --log              # ログ表示
#   claude-watch --history          # 実行履歴

set -euo pipefail

# === 設定 ===
WATCH_DIR="$HOME/.claude/watch"
PID_FILE="$WATCH_DIR/watcher.pid"
LOG_FILE="$WATCH_DIR/watcher.log"
HISTORY_FILE="$WATCH_DIR/history.md"
DEFAULT_TARGET="$HOME/instructions.md"
POLL_INTERVAL=5  # ポーリング間隔（秒）

# 色定義
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# === 初期化 ===
mkdir -p "$WATCH_DIR"

# === ユーティリティ ===
timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

log() {
    local msg="[$(timestamp)] $1"
    echo "$msg" >> "$LOG_FILE"
    echo -e "${CYAN}$msg${NC}"
}

log_silent() {
    echo "[$(timestamp)] $1" >> "$LOG_FILE"
}

# === コマンド ===
show_help() {
    echo -e "${BOLD}claude-watch${NC} - instructions.md 自動実行ウォッチャー"
    echo ""
    echo "Usage:"
    echo "  claude-watch [file]           監視開始（デフォルト: ~/instructions.md）"
    echo "  claude-watch --status         状態確認"
    echo "  claude-watch --stop           停止"
    echo "  claude-watch --log            ログ表示（最新50行）"
    echo "  claude-watch --log-full       ログ全文表示"
    echo "  claude-watch --history        実行履歴"
    echo "  claude-watch --clear-history  履歴クリア"
    echo ""
    echo "Options:"
    echo "  --model <model>   使用モデル（デフォルト: sonnet）"
    echo "  --dir <dir>       Claude Codeの作業ディレクトリ"
    echo "  --fg              フォアグラウンドで実行（デフォルト: バックグラウンド）"
    echo ""
    echo "Examples:"
    echo "  claude-watch                           # ~/instructions.md を監視開始"
    echo "  claude-watch ~/projects/tasks.md       # 別ファイルを監視"
    echo "  claude-watch --model opus              # opusモデルで実行"
    echo "  claude-watch --dir ~/projects/myapp    # 作業ディレクトリ指定"
    echo ""
    echo "仕組み:"
    echo "  1. ${POLL_INTERVAL}秒ごとにファイルのタイムスタンプをチェック"
    echo "  2. 変更があればファイル内容を読み取り"
    echo "  3. 空でなければ claude -p で実行"
    echo "  4. 実行後、ファイルに完了マーカーを追記"
    echo "  5. 結果をhistoryに記録"
    echo ""
    echo "Note:"
    echo "  ポーリング方式のため外部依存なし（inotify不要）"
    echo "  WSL2でWindows側エディタからの書き込みも検知可能"
}

show_status() {
    echo -e "${BOLD}=== claude-watch ステータス ===${NC}"
    echo ""

    if [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  状態: ${GREEN}稼働中${NC} (PID: $pid)"
            # 監視対象ファイルを表示
            if [ -f "$WATCH_DIR/target" ]; then
                echo -e "  監視: $(cat "$WATCH_DIR/target")"
            fi
            # 起動時刻
            if [ -f "$WATCH_DIR/started_at" ]; then
                echo -e "  起動: $(cat "$WATCH_DIR/started_at")"
            fi
            # 実行回数
            if [ -f "$WATCH_DIR/exec_count" ]; then
                echo -e "  実行: $(cat "$WATCH_DIR/exec_count") 回"
            fi
        else
            echo -e "  状態: ${RED}停止${NC}（PIDファイルが残存）"
            rm -f "$PID_FILE"
        fi
    else
        echo -e "  状態: ${YELLOW}未起動${NC}"
    fi
    echo ""
}

stop_watcher() {
    if [ -f "$PID_FILE" ]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            # プロセスグループ全体を停止（子プロセスも含む）
            kill -- -"$pid" 2>/dev/null || kill "$pid" 2>/dev/null
            echo -e "${GREEN}ウォッチャーを停止しました${NC} (PID: $pid)"
            log_silent "停止 (PID: $pid)"
        else
            echo -e "${YELLOW}ウォッチャーは既に停止しています${NC}"
        fi
        rm -f "$PID_FILE"
    else
        echo -e "${YELLOW}ウォッチャーは起動していません${NC}"
    fi
}

show_log() {
    local lines="${1:-50}"
    if [ -f "$LOG_FILE" ]; then
        echo -e "${BOLD}=== ウォッチャーログ（最新${lines}行） ===${NC}"
        tail -n "$lines" "$LOG_FILE"
    else
        echo "ログがありません"
    fi
}

show_history() {
    if [ -f "$HISTORY_FILE" ]; then
        cat "$HISTORY_FILE"
    else
        echo "実行履歴がありません"
    fi
}

# === instruction-id 抽出 ===
# ファイル内容から <!-- instruction-id: UUID --> パターンを探し、IDを返す
# IDがない場合は空文字を返す（従来動作にフォールバック）
get_instruction_id() {
    local content="$1"
    echo "$content" | grep -oP '<!-- instruction-id: \K[^ ]+(?= --)' | head -1
}

# === 実行完了マーカー ===
# instructions.mdに結果を追記して、人間が確認できるようにする
mark_completed() {
    local target="$1"
    local status="$2"  # success / error
    local summary="$3"

    {
        echo ""
        echo "---"
        echo "<!-- claude-watch: ${status} at $(timestamp) -->"
        if [ "$status" = "success" ]; then
            echo "## 実行完了 ($(timestamp))"
        else
            echo "## 実行エラー ($(timestamp))"
        fi
        echo ""
        echo "$summary"
        echo ""
        # 終了マーカー: after_markerチェックで「ここまでが出力」と判別するため
        echo "<!-- claude-watch-end -->"
    } >> "$target"
}

# === 履歴記録 ===
record_history() {
    local target="$1"
    local status="$2"
    local instruction_preview="$3"

    {
        echo "### $(timestamp) [$status]"
        echo "- ファイル: $target"
        echo "- 指示（先頭100文字）: ${instruction_preview:0:100}"
        echo ""
    } >> "$HISTORY_FILE"
}

# === ファイルのmtime取得（エポック秒） ===
get_mtime() {
    stat -c %Y "$1" 2>/dev/null || echo "0"
}

# === メインの監視・実行ループ ===
# ポーリング方式: POLL_INTERVAL秒ごとにタイムスタンプをチェック
# WSL2でWindows側エディタの書き込みを確実に検知するため
watch_and_execute() {
    local target="$1"
    local model="${2:-sonnet}"
    local work_dir="${3:-$HOME}"

    # 監視対象ファイルが無ければ作成
    if [ ! -f "$target" ]; then
        echo "# Instructions" > "$target"
        echo "# ここに指示を書いてください。保存するとClaude Codeが自動実行します。" >> "$target"
        log "監視対象ファイルを作成: $target"
    fi

    # instruction-idベースの重複実行防止
    # instructions.mdの先頭に <!-- instruction-id: UUID --> があれば
    # そのIDを記録し、同じIDの指示は再実行しない
    local EXECUTED_IDS_FILE="$WATCH_DIR/executed_ids"
    touch "$EXECUTED_IDS_FILE"

    # 実行カウント初期化
    echo "0" > "$WATCH_DIR/exec_count"
    echo "$target" > "$WATCH_DIR/target"
    echo "$(timestamp)" > "$WATCH_DIR/started_at"

    # 現在のmtimeを記録（起動時点の状態を「既知」とする）
    local last_mtime
    last_mtime=$(get_mtime "$target")

    log "監視開始: $target (model: $model, dir: $work_dir, poll: ${POLL_INTERVAL}s)"

    # ポーリングループ
    while true; do
        sleep "$POLL_INTERVAL"

        # ファイルが存在しなければスキップ
        if [ ! -f "$target" ]; then
            continue
        fi

        # タイムスタンプ比較
        local current_mtime
        current_mtime=$(get_mtime "$target")

        if [ "$current_mtime" = "$last_mtime" ]; then
            # 変更なし
            continue
        fi

        # 変更検知 — mtimeを即座に更新（二重実行防止）
        last_mtime="$current_mtime"

        log "ファイル変更を検知 (mtime: $current_mtime)"

        # ファイル内容を読み取り
        local content
        content=$(cat "$target" 2>/dev/null || echo "")

        # 空またはテンプレートのみなら無視
        # grep -qP '^#.*\n?$' は行単位なので#行が1つでもあるとマッチしてしまうバグがあった
        # 修正: コメント行・空行を全て除去し、残りがなければスキップ
        local stripped_content
        stripped_content=$(echo "$content" | grep -v '^#' | grep -v '^[[:space:]]*$' | grep -v '^---$')
        if [ -z "$content" ] || [ -z "$stripped_content" ]; then
            log_silent "ファイルが空またはテンプレートのみ - スキップ"
            continue
        fi

        # 既に実行済みマーカーがあり、新しい指示がなければスキップ
        # 終了マーカー(claude-watch-end)以降に有効な指示があるかチェック
        if echo "$content" | grep -q '<!-- claude-watch-end -->'; then
            local after_end
            # 最後の終了マーカー以降のテキストを取得
            after_end=$(echo "$content" | tac | sed '/<!-- claude-watch-end -->/q' | tac | tail -n +2)
            # 空行、区切り線、コメント行を除去して有効な指示があるか判定
            after_end=$(echo "$after_end" | sed '/^$/d' | sed '/^---$/d' | sed '/^<!--/d')
            if [ -z "$after_end" ]; then
                log_silent "新しい指示なし（終了マーカー以降に内容なし） - スキップ"
                continue
            fi
        # 開始マーカーのみで終了マーカーなし（実行中に中断された場合）
        elif echo "$content" | grep -q '<!-- claude-watch:.*-->'; then
            local after_marker
            after_marker=$(echo "$content" | tac | sed '/<!-- claude-watch:/q' | tac | tail -n +2)
            after_marker=$(echo "$after_marker" | sed '/^$/d' | sed '/^---$/d' | sed '/^##/d' | sed '/^<!--/d')
            if [ -z "$after_marker" ]; then
                log_silent "新しい指示なし（マーカー追記による変更） - スキップ"
                continue
            fi
        fi

        # 実行済みマーカーより前の部分を指示として取得
        # 終了マーカー以降の新しい指示を抽出する
        local instruction
        if echo "$content" | grep -q '<!-- claude-watch-end -->'; then
            # 最後の終了マーカー以降の部分を取得
            instruction=$(echo "$content" | tac | sed '/<!-- claude-watch-end -->/q' | tac | tail -n +2)
        elif echo "$content" | grep -q '<!-- claude-watch:'; then
            # 終了マーカーなし（中断等）: 最後の開始マーカー以降を取得
            instruction=$(echo "$content" | tac | sed '/<!-- claude-watch:/q' | tac | tail -n +2)
        else
            instruction="$content"
        fi
        # 装飾行・マーカー行・空行を除去
        instruction=$(echo "$instruction" | grep -v '^---$' | grep -v '^<!-- claude-watch' | grep -v '^## 実行完了' | grep -v '^## 実行エラー' | sed '/^$/N;/^\n$/d')

        # コメント行のみなら無視
        instruction=$(echo "$instruction" | grep -v '^#.*ここに指示' | grep -v '^# Instructions$')
        instruction=$(echo "$instruction" | sed '/^[[:space:]]*$/d')

        if [ -z "$instruction" ]; then
            log_silent "有効な指示なし - スキップ"
            continue
        fi

        # instruction-idベースの重複チェック
        # IDがあれば既に実行済みかを確認し、実行済みならスキップ
        # IDがなければ従来通りmtime+マーカーベースで処理を継続
        local instruction_id
        instruction_id=$(get_instruction_id "$content")
        if [ -n "$instruction_id" ]; then
            if grep -qxF "$instruction_id" "$EXECUTED_IDS_FILE" 2>/dev/null; then
                log_silent "instruction-id $instruction_id は実行済み - スキップ"
                continue
            fi
            log "instruction-id検出: $instruction_id"
        fi

        # 実行カウント更新
        local count
        count=$(cat "$WATCH_DIR/exec_count" 2>/dev/null || echo "0")
        count=$((count + 1))
        echo "$count" > "$WATCH_DIR/exec_count"

        log "=== 実行 #$count 開始 ==="
        log "指示: ${instruction:0:200}"

        # Claude Code実行
        # -p: 非対話モード
        local output
        local exit_code=0
        output=$(cd "$work_dir" && echo "$instruction" | claude -p --dangerously-skip-permissions \
            --model "$model" \
            2>&1) || exit_code=$?

        if [ $exit_code -eq 0 ]; then
            log "=== 実行 #$count 完了（成功） ==="
            mark_completed "$target" "success" "$output"
            record_history "$target" "SUCCESS" "$instruction"
        else
            log "=== 実行 #$count 完了（エラー: exit=$exit_code） ==="
            mark_completed "$target" "error" "Exit code: $exit_code\n\n$output"
            record_history "$target" "ERROR" "$instruction"
        fi

        # instruction-idを実行済みとして記録
        # 成功・失敗に関わらず記録する（同じ失敗指示の無限再実行を防ぐ）
        if [ -n "$instruction_id" ]; then
            echo "$instruction_id" >> "$EXECUTED_IDS_FILE"
            log "instruction-id $instruction_id を実行済みとして記録"
        fi

        log_silent "出力（先頭500文字）: ${output:0:500}"

        # mark_completedがファイルに追記するのでmtimeを再取得
        # これで自分自身の書き込みで再トリガーしない
        last_mtime=$(get_mtime "$target")
    done
}

# === メイン ===
main() {
    local target="$DEFAULT_TARGET"
    local model="sonnet"
    local work_dir="$HOME"
    local foreground=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --status)
                show_status
                exit 0
                ;;
            --stop)
                stop_watcher
                exit 0
                ;;
            --log)
                show_log "${2:-50}"
                exit 0
                ;;
            --log-full)
                show_log 99999
                exit 0
                ;;
            --history)
                show_history
                exit 0
                ;;
            --clear-history)
                rm -f "$HISTORY_FILE"
                echo "履歴をクリアしました"
                exit 0
                ;;
            --model)
                model="$2"
                shift
                ;;
            --dir)
                work_dir="$2"
                shift
                ;;
            --fg)
                foreground=true
                ;;
            *)
                # 引数がファイルパスなら監視対象として使う
                if [[ "$1" != -* ]]; then
                    target="$1"
                else
                    echo -e "${RED}不明なオプション: $1${NC}"
                    show_help
                    exit 1
                fi
                ;;
        esac
        shift
    done

    # 既に起動中かチェック（フォアグラウンド再呼び出し時はスキップ）
    if ! $foreground && [ -f "$PID_FILE" ]; then
        local existing_pid
        existing_pid=$(cat "$PID_FILE")
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo -e "${YELLOW}ウォッチャーは既に起動中です${NC} (PID: $existing_pid)"
            echo "停止するには: claude-watch --stop"
            exit 1
        fi
        rm -f "$PID_FILE"
    fi

    if $foreground; then
        # フォアグラウンド実行（Ctrl+Cで停止）
        echo -e "${GREEN}ウォッチャー起動（フォアグラウンド）${NC}"
        echo -e "監視:     ${BOLD}$target${NC}"
        echo -e "モデル:   $model"
        echo -e "作業DIR:  $work_dir"
        echo -e "間隔:     ${POLL_INTERVAL}秒"
        echo -e "停止:     Ctrl+C"
        echo ""

        # PIDファイル書き込み（フォアグラウンドでも状態確認用）
        echo $$ > "$PID_FILE"
        trap 'rm -f "$PID_FILE"; log "停止（フォアグラウンド）"; exit 0' INT TERM

        watch_and_execute "$target" "$model" "$work_dir"
    else
        # バックグラウンド実行
        # nohupで端末切断に耐える
        nohup "$0" --fg --model "$model" --dir "$work_dir" "$target" \
            >> "$LOG_FILE" 2>&1 &
        local bg_pid=$!
        # --fgモードが自分でPIDファイルを書くが、念のため上書き
        echo "$bg_pid" > "$PID_FILE"

        echo -e "${GREEN}ウォッチャーをバックグラウンドで起動しました${NC}"
        echo -e "  PID:     $bg_pid"
        echo -e "  監視:    ${BOLD}$target${NC}"
        echo -e "  モデル:  $model"
        echo -e "  作業DIR: $work_dir"
        echo -e "  間隔:    ${POLL_INTERVAL}秒"
        echo ""
        echo -e "  ステータス: claude-watch --status"
        echo -e "  ログ:       claude-watch --log"
        echo -e "  停止:       claude-watch --stop"
    fi
}

# 直接実行された場合のみmainを呼ぶ（source対応）
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
